## Установка
Для установки потребуются:
* Python
* Pipenv
* ffmpeg
* Docker

Установка:
```
pipenv shell 
pipenv install
docker compose up
alembic upgrade head
```
## Endpoints

###  upload : `POST /upload`
Запрос на обработку видео

form-data object с
* `video`: сам видеофайл
* `pitch`: коэффициент питчинга (опционально) отличный от 1

cURL пример:
```
curl --location --request POST 'localhost:8888/upload'
--form 'video=@"path/to/video.mp4'
--form 'pitch="1.1"'
```

Проверяем соответствие `video` на mime типу (video/mp4, video/mpeg и тп). Если параметр `pitch` пришел отрицательным или 
некорректным, то мы его зануляем .

Из питча и битов видео формируем md5, затем берем из него uuid, это будет нашим неким уникальным
 идентификатором для "ленивой" обработки последующих одинаковых post запросов. Т.е. если придет аналогичный запрос, то вернет предыдущий результат выполненной обработки. 

Записываем в базу кол-во чанков, uuid, оригинальное название файла. База инкрементирует id, это и будет наш конечный путь чанков (trim_results/id/*).

Меняем питч и сегментируем через ffmpeg, он же и формирует .m3u8 файл.

Возвращаем id.

### download : `GET /download`
Запрос на m3u8 файл обработанного видео

Один query parameter
* `id`: айди обработанного файла

cURL пример:
```
curl --location --request GET 'localhost:8888/download?id=1'
```

Проверяем на соответствие типу, проверяем вхождение в базу.

Формируем путь из базы по id и оригинальному названию видеофайла,
достаем m3u8 файл и дополняем информацию о чанках url'ом сервера, то есть `videochunk0.ts -> http://localhost:8888/trim_results/1/videochunk0.ts`, НО если раньше так не делали.

Возвращаем url с путем до m3u8 файла.

### trim_results : `GET /trim_results/(.*)`

Открыли доступ до конечных файлов (чанков и плейлиста).

Теперь можно прогонять плейлисты из download, чанки смотрят на сервер, а не на файловую систему (проверялось на VLC).

